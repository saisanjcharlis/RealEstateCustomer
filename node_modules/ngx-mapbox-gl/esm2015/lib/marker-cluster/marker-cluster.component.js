/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, EventEmitter, Input, NgZone, Output, TemplateRef } from '@angular/core';
import { fromEvent, merge, Subscription } from 'rxjs';
import { startWith } from 'rxjs/operators';
import Supercluster from 'supercluster';
import { MapService } from '../map/map.service';
import { ClusterPointDirective, PointDirective } from '../markers-for-clusters/markers-for-clusters.component';
export class MarkerClusterComponent {
    /**
     * @param {?} MapService
     * @param {?} ChangeDetectorRef
     * @param {?} zone
     */
    constructor(MapService, ChangeDetectorRef, zone) {
        this.MapService = MapService;
        this.ChangeDetectorRef = ChangeDetectorRef;
        this.zone = zone;
        this.load = new EventEmitter();
        this.sub = new Subscription();
        this.getLeavesFn = (/**
         * @param {?} feature
         * @return {?}
         */
        (feature) => {
            return (/**
             * @param {?=} limit
             * @param {?=} offset
             * @return {?}
             */
            (limit, offset) => ((/** @type {?} */ (this.supercluster.getLeaves)))((/** @type {?} */ (feature.properties.cluster_id)), limit, offset));
        });
        this.getChildrenFn = (/**
         * @param {?} feature
         * @return {?}
         */
        (feature) => {
            return (/**
             * @return {?}
             */
            () => ((/** @type {?} */ (this.supercluster.getChildren)))((/** @type {?} */ (feature.properties.cluster_id))));
        });
        this.getClusterExpansionZoomFn = (/**
         * @param {?} feature
         * @return {?}
         */
        (feature) => {
            return (/**
             * @return {?}
             */
            () => ((/** @type {?} */ (this.supercluster.getClusterExpansionZoom)))((/** @type {?} */ (feature.properties.cluster_id))));
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        console.warn('[ngx-mapbox-gl] mgl-marker-cluster is deprecated, use mgl-markers-for-clusters instead');
        /** @type {?} */
        const options = {
            radius: this.radius,
            maxZoom: this.maxZoom,
            minZoom: this.minZoom,
            extent: this.extent,
            nodeSize: this.nodeSize,
            log: this.log,
            reduce: this.reduce,
            map: this.map
        };
        Object.keys(options)
            .forEach((/**
         * @param {?} key
         * @return {?}
         */
        (key) => {
            /** @type {?} */
            const tkey = (/** @type {?} */ (key));
            if (options[tkey] === undefined) {
                delete options[tkey];
            }
        }));
        this.supercluster = new Supercluster(options);
        this.supercluster.load(this.data.features);
        this.load.emit(this.supercluster);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.data && !changes.data.isFirstChange()) {
            this.supercluster.load(this.data.features);
            this.updateCluster();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.MapService.mapCreated$.subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const mapMove$ = merge(fromEvent((/** @type {?} */ (this.MapService.mapInstance)), 'zoomChange'), fromEvent((/** @type {?} */ (this.MapService.mapInstance)), 'move'));
            /** @type {?} */
            const sub = mapMove$.pipe(startWith(undefined)).subscribe((/**
             * @return {?}
             */
            () => {
                this.zone.run((/**
                 * @return {?}
                 */
                () => {
                    this.updateCluster();
                }));
            }));
            this.sub.add(sub);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    /**
     * @private
     * @return {?}
     */
    updateCluster() {
        /** @type {?} */
        const bbox = this.MapService.getCurrentViewportBbox();
        /** @type {?} */
        const currentZoom = Math.round(this.MapService.mapInstance.getZoom());
        this.clusterPoints = this.supercluster.getClusters(bbox, currentZoom);
        this.ChangeDetectorRef.markForCheck();
    }
}
MarkerClusterComponent.decorators = [
    { type: Component, args: [{
                selector: 'mgl-marker-cluster',
                template: `
    <ng-container *ngFor="let feature of clusterPoints">
      <ng-container *ngIf="feature.properties.cluster; else point">
        <mgl-marker
          [feature]="feature"
        >
          <ng-container *ngTemplateOutlet="clusterPointTpl; context: {
            $implicit: feature,
            getLeavesFn: getLeavesFn(feature),
            getChildrenFn: getChildrenFn(feature),
            getClusterExpansionZoomFn: getClusterExpansionZoomFn(feature)
          }"></ng-container>
        </mgl-marker>
      </ng-container>
      <ng-template #point>
        <mgl-marker
          [feature]="feature"
        >
          <ng-container *ngTemplateOutlet="pointTpl; context: { $implicit: feature }"></ng-container>
        </mgl-marker>
      </ng-template>
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            }] }
];
/** @nocollapse */
MarkerClusterComponent.ctorParameters = () => [
    { type: MapService },
    { type: ChangeDetectorRef },
    { type: NgZone }
];
MarkerClusterComponent.propDecorators = {
    radius: [{ type: Input }],
    maxZoom: [{ type: Input }],
    minZoom: [{ type: Input }],
    extent: [{ type: Input }],
    nodeSize: [{ type: Input }],
    log: [{ type: Input }],
    reduce: [{ type: Input }],
    map: [{ type: Input }],
    data: [{ type: Input }],
    load: [{ type: Output }],
    pointTpl: [{ type: ContentChild, args: [PointDirective, { read: TemplateRef },] }],
    clusterPointTpl: [{ type: ContentChild, args: [ClusterPointDirective, { read: TemplateRef },] }]
};
if (false) {
    /** @type {?} */
    MarkerClusterComponent.prototype.radius;
    /** @type {?} */
    MarkerClusterComponent.prototype.maxZoom;
    /** @type {?} */
    MarkerClusterComponent.prototype.minZoom;
    /** @type {?} */
    MarkerClusterComponent.prototype.extent;
    /** @type {?} */
    MarkerClusterComponent.prototype.nodeSize;
    /** @type {?} */
    MarkerClusterComponent.prototype.log;
    /** @type {?} */
    MarkerClusterComponent.prototype.reduce;
    /** @type {?} */
    MarkerClusterComponent.prototype.map;
    /** @type {?} */
    MarkerClusterComponent.prototype.data;
    /** @type {?} */
    MarkerClusterComponent.prototype.load;
    /** @type {?} */
    MarkerClusterComponent.prototype.pointTpl;
    /** @type {?} */
    MarkerClusterComponent.prototype.clusterPointTpl;
    /** @type {?} */
    MarkerClusterComponent.prototype.clusterPoints;
    /**
     * @type {?}
     * @private
     */
    MarkerClusterComponent.prototype.supercluster;
    /**
     * @type {?}
     * @private
     */
    MarkerClusterComponent.prototype.sub;
    /** @type {?} */
    MarkerClusterComponent.prototype.getLeavesFn;
    /** @type {?} */
    MarkerClusterComponent.prototype.getChildrenFn;
    /** @type {?} */
    MarkerClusterComponent.prototype.getClusterExpansionZoomFn;
    /**
     * @type {?}
     * @private
     */
    MarkerClusterComponent.prototype.MapService;
    /**
     * @type {?}
     * @private
     */
    MarkerClusterComponent.prototype.ChangeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    MarkerClusterComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya2VyLWNsdXN0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LW1hcGJveC1nbC8iLCJzb3VyY2VzIjpbImxpYi9tYXJrZXItY2x1c3Rlci9tYXJrZXItY2x1c3Rlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osWUFBWSxFQUNaLEtBQUssRUFDTCxNQUFNLEVBSU4sTUFBTSxFQUVOLFdBQVcsRUFDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sWUFBeUMsTUFBTSxjQUFjLENBQUM7QUFDckUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxjQUFjLEVBQUUsTUFBTSx3REFBd0QsQ0FBQztBQThCL0csTUFBTSxPQUFPLHNCQUFzQjs7Ozs7O0lBd0JqQyxZQUNVLFVBQXNCLEVBQ3RCLGlCQUFvQyxFQUNwQyxJQUFZO1FBRlosZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQ3BDLFNBQUksR0FBSixJQUFJLENBQVE7UUFiWixTQUFJLEdBQUcsSUFBSSxZQUFZLEVBQXNFLENBQUM7UUFRaEcsUUFBRyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUE0RGpDLGdCQUFXOzs7O1FBQUcsQ0FBQyxPQUFrRCxFQUFFLEVBQUU7WUFDbkU7Ozs7O1lBQU8sQ0FBQyxLQUFjLEVBQUUsTUFBZSxFQUFFLEVBQUUsQ0FBQyxDQUFDLG1CQUFLLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFBLENBQUMsQ0FB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Q0FBeUI7O0lBQ3pCLHlDQUEwQjs7SUFDMUIseUNBQTBCOztJQUMxQix3Q0FBeUI7O0lBQ3pCLDBDQUEyQjs7SUFDM0IscUNBQXVCOztJQUN2Qix3Q0FBeUQ7O0lBQ3pELHFDQUFtQzs7SUFHbkMsc0NBQXdEOztJQUV4RCxzQ0FBd0c7O0lBRXhHLDBDQUFnRjs7SUFDaEYsaURBQThGOztJQUU5RiwrQ0FBZ0Q7Ozs7O0lBRWhELDhDQUF5Rjs7Ozs7SUFDekYscUNBQWlDOztJQTREakMsNkNBRUM7O0lBRUQsK0NBRUM7O0lBRUQsMkRBRUM7Ozs7O0lBbkVDLDRDQUE4Qjs7Ozs7SUFDOUIsbURBQTRDOzs7OztJQUM1QyxzQ0FBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCBTdXBlcmNsdXN0ZXIsIHsgQ2x1c3RlckZlYXR1cmUsIE9wdGlvbnMgfSBmcm9tICdzdXBlcmNsdXN0ZXInO1xuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBDbHVzdGVyUG9pbnREaXJlY3RpdmUsIFBvaW50RGlyZWN0aXZlIH0gZnJvbSAnLi4vbWFya2Vycy1mb3ItY2x1c3RlcnMvbWFya2Vycy1mb3ItY2x1c3RlcnMuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWdsLW1hcmtlci1jbHVzdGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBmZWF0dXJlIG9mIGNsdXN0ZXJQb2ludHNcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJmZWF0dXJlLnByb3BlcnRpZXMuY2x1c3RlcjsgZWxzZSBwb2ludFwiPlxuICAgICAgICA8bWdsLW1hcmtlclxuICAgICAgICAgIFtmZWF0dXJlXT1cImZlYXR1cmVcIlxuICAgICAgICA+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNsdXN0ZXJQb2ludFRwbDsgY29udGV4dDoge1xuICAgICAgICAgICAgJGltcGxpY2l0OiBmZWF0dXJlLFxuICAgICAgICAgICAgZ2V0TGVhdmVzRm46IGdldExlYXZlc0ZuKGZlYXR1cmUpLFxuICAgICAgICAgICAgZ2V0Q2hpbGRyZW5GbjogZ2V0Q2hpbGRyZW5GbihmZWF0dXJlKSxcbiAgICAgICAgICAgIGdldENsdXN0ZXJFeHBhbnNpb25ab29tRm46IGdldENsdXN0ZXJFeHBhbnNpb25ab29tRm4oZmVhdHVyZSlcbiAgICAgICAgICB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbWdsLW1hcmtlcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPG5nLXRlbXBsYXRlICNwb2ludD5cbiAgICAgICAgPG1nbC1tYXJrZXJcbiAgICAgICAgICBbZmVhdHVyZV09XCJmZWF0dXJlXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJwb2ludFRwbDsgY29udGV4dDogeyAkaW1wbGljaXQ6IGZlYXR1cmUgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L21nbC1tYXJrZXI+XG4gICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2Vcbn0pXG5leHBvcnQgY2xhc3MgTWFya2VyQ2x1c3RlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0LCBPbkluaXQge1xuICAvKiBJbml0IGlucHV0ICovXG4gIEBJbnB1dCgpIHJhZGl1cz86IG51bWJlcjtcbiAgQElucHV0KCkgbWF4Wm9vbT86IG51bWJlcjtcbiAgQElucHV0KCkgbWluWm9vbT86IG51bWJlcjtcbiAgQElucHV0KCkgZXh0ZW50PzogbnVtYmVyO1xuICBASW5wdXQoKSBub2RlU2l6ZT86IG51bWJlcjtcbiAgQElucHV0KCkgbG9nPzogYm9vbGVhbjtcbiAgQElucHV0KCkgcmVkdWNlPzogKGFjY3VtdWxhdGVkOiBhbnksIHByb3BzOiBhbnkpID0+IHZvaWQ7XG4gIEBJbnB1dCgpIG1hcD86IChwcm9wczogYW55KSA9PiBhbnk7XG5cbiAgLyogRHluYW1pYyBpbnB1dCAqL1xuICBASW5wdXQoKSBkYXRhOiBHZW9KU09OLkZlYXR1cmVDb2xsZWN0aW9uPEdlb0pTT04uUG9pbnQ+O1xuXG4gIEBPdXRwdXQoKSBsb2FkID0gbmV3IEV2ZW50RW1pdHRlcjxTdXBlcmNsdXN0ZXI8R2VvSlNPTi5HZW9Kc29uUHJvcGVydGllcywgR2VvSlNPTi5HZW9Kc29uUHJvcGVydGllcz4+KCk7XG5cbiAgQENvbnRlbnRDaGlsZChQb2ludERpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KSBwb2ludFRwbDogVGVtcGxhdGVSZWY8YW55PjtcbiAgQENvbnRlbnRDaGlsZChDbHVzdGVyUG9pbnREaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgY2x1c3RlclBvaW50VHBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNsdXN0ZXJQb2ludHM6IEdlb0pTT04uRmVhdHVyZTxHZW9KU09OLlBvaW50PltdO1xuXG4gIHByaXZhdGUgc3VwZXJjbHVzdGVyOiBTdXBlcmNsdXN0ZXI8R2VvSlNPTi5HZW9Kc29uUHJvcGVydGllcywgR2VvSlNPTi5HZW9Kc29uUHJvcGVydGllcz47XG4gIHByaXZhdGUgc3ViID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgTWFwU2VydmljZTogTWFwU2VydmljZSxcbiAgICBwcml2YXRlIENoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlIHpvbmU6IE5nWm9uZVxuICApIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGNvbnNvbGUud2FybignW25neC1tYXBib3gtZ2xdIG1nbC1tYXJrZXItY2x1c3RlciBpcyBkZXByZWNhdGVkLCB1c2UgbWdsLW1hcmtlcnMtZm9yLWNsdXN0ZXJzIGluc3RlYWQnKTtcbiAgICBjb25zdCBvcHRpb25zOiBPcHRpb25zPEdlb0pTT04uR2VvSnNvblByb3BlcnRpZXMsIEdlb0pTT04uR2VvSnNvblByb3BlcnRpZXM+ID0ge1xuICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1cyxcbiAgICAgIG1heFpvb206IHRoaXMubWF4Wm9vbSxcbiAgICAgIG1pblpvb206IHRoaXMubWluWm9vbSxcbiAgICAgIGV4dGVudDogdGhpcy5leHRlbnQsXG4gICAgICBub2RlU2l6ZTogdGhpcy5ub2RlU2l6ZSxcbiAgICAgIGxvZzogdGhpcy5sb2csXG4gICAgICByZWR1Y2U6IHRoaXMucmVkdWNlLFxuICAgICAgbWFwOiB0aGlzLm1hcFxuICAgIH07XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucylcbiAgICAgIC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCB0a2V5ID0gPGtleW9mIE9wdGlvbnM8R2VvSlNPTi5HZW9Kc29uUHJvcGVydGllcywgR2VvSlNPTi5HZW9Kc29uUHJvcGVydGllcz4+a2V5O1xuICAgICAgICBpZiAob3B0aW9uc1t0a2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnNbdGtleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHRoaXMuc3VwZXJjbHVzdGVyID0gbmV3IFN1cGVyY2x1c3RlcjxHZW9KU09OLkdlb0pzb25Qcm9wZXJ0aWVzLCBHZW9KU09OLkdlb0pzb25Qcm9wZXJ0aWVzPihvcHRpb25zKTtcbiAgICB0aGlzLnN1cGVyY2x1c3Rlci5sb2FkKHRoaXMuZGF0YS5mZWF0dXJlcyk7XG4gICAgdGhpcy5sb2FkLmVtaXQodGhpcy5zdXBlcmNsdXN0ZXIpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzLmRhdGEgJiYgIWNoYW5nZXMuZGF0YS5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgIHRoaXMuc3VwZXJjbHVzdGVyLmxvYWQodGhpcy5kYXRhLmZlYXR1cmVzKTtcbiAgICAgIHRoaXMudXBkYXRlQ2x1c3RlcigpO1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLk1hcFNlcnZpY2UubWFwQ3JlYXRlZCQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IG1hcE1vdmUkID0gbWVyZ2UoXG4gICAgICAgIGZyb21FdmVudCg8YW55PnRoaXMuTWFwU2VydmljZS5tYXBJbnN0YW5jZSwgJ3pvb21DaGFuZ2UnKSxcbiAgICAgICAgZnJvbUV2ZW50KDxhbnk+dGhpcy5NYXBTZXJ2aWNlLm1hcEluc3RhbmNlLCAnbW92ZScpXG4gICAgICApO1xuICAgICAgY29uc3Qgc3ViID0gbWFwTW92ZSQucGlwZShcbiAgICAgICAgc3RhcnRXaXRoPGFueT4odW5kZWZpbmVkKVxuICAgICAgKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNsdXN0ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3ViLmFkZChzdWIpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWIudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIGdldExlYXZlc0ZuID0gKGZlYXR1cmU6IENsdXN0ZXJGZWF0dXJlPEdlb0pTT04uR2VvSnNvblByb3BlcnRpZXM+KSA9PiB7XG4gICAgcmV0dXJuIChsaW1pdD86IG51bWJlciwgb2Zmc2V0PzogbnVtYmVyKSA9PiAoPGFueT50aGlzLnN1cGVyY2x1c3Rlci5nZXRMZWF2ZXMpKGZlYXR1cmUucHJvcGVydGllcy5jbHVzdGVyX2lkISwgbGltaXQsIG9mZnNldCk7XG4gIH1cblxuICBnZXRDaGlsZHJlbkZuID0gKGZlYXR1cmU6IENsdXN0ZXJGZWF0dXJlPEdlb0pTT04uR2VvSnNvblByb3BlcnRpZXM+KSA9PiB7XG4gICAgcmV0dXJuICgpID0+ICg8YW55PnRoaXMuc3VwZXJjbHVzdGVyLmdldENoaWxkcmVuKShmZWF0dXJlLnByb3BlcnRpZXMuY2x1c3Rlcl9pZCEpO1xuICB9XG5cbiAgZ2V0Q2x1c3RlckV4cGFuc2lvblpvb21GbiA9IChmZWF0dXJlOiBDbHVzdGVyRmVhdHVyZTxHZW9KU09OLkdlb0pzb25Qcm9wZXJ0aWVzPikgPT4ge1xuICAgIHJldHVybiAoKSA9PiAoPGFueT50aGlzLnN1cGVyY2x1c3Rlci5nZXRDbHVzdGVyRXhwYW5zaW9uWm9vbSkoZmVhdHVyZS5wcm9wZXJ0aWVzLmNsdXN0ZXJfaWQhKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ2x1c3RlcigpIHtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5NYXBTZXJ2aWNlLmdldEN1cnJlbnRWaWV3cG9ydEJib3goKTtcbiAgICBjb25zdCBjdXJyZW50Wm9vbSA9IE1hdGgucm91bmQodGhpcy5NYXBTZXJ2aWNlLm1hcEluc3RhbmNlLmdldFpvb20oKSk7XG4gICAgdGhpcy5jbHVzdGVyUG9pbnRzID0gdGhpcy5zdXBlcmNsdXN0ZXIuZ2V0Q2x1c3RlcnMoYmJveCwgY3VycmVudFpvb20pO1xuICAgIHRoaXMuQ2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cbn1cbiJdfQ==