/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { AirCalendar, AirLanguage, AirOptions } from '../../classes';
export class DatepickerComponent {
    constructor() {
        this.setDate = new EventEmitter();
        this.setMonth = new EventEmitter();
        this.monthSelection = new EventEmitter();
    }
}
DatepickerComponent.decorators = [
    { type: Component, args: [{
                selector: '[datepicker]',
                template: `
    <nav class="datepicker--nav">
      <div class="datepicker--nav-action" (click)="setMonth.emit(airCalendar.month - 1)"><svg><path d="M 17,12 l -5,5 l 5,5"></path></svg></div>

      <div (click)="monthSelection.emit()" class="datepicker--nav-title">{{airLanguage.months[airCalendar.month]}}, <i>{{airCalendar.year}}</i></div>

      <div class="datepicker--nav-action" (click)="setMonth.emit(airCalendar.month + 1)"><svg><path d="M 14,12 l 5,5 l -5,5"></path></svg></div>
    </nav>

    <div class="datepicker--content">
      <div class="datepicker--days datepicker--body active">
        <div class="datepicker--days-names">
          <div *ngFor="let day of [0,1,2,3,4,5,6]" class="datepicker--day-name" [class.-weekend-]="day == 5 || day == 6"
          >{{airLanguage[airOptions.fullDays ? 'days' : 'daysMin'][day]}}</div>
        </div>

        <div class="datepicker--cells datepicker--cells-days">
          <div *ngFor="let airDay of airCalendar.airDays; let i=index"
               class="datepicker--cell datepicker--cell-day"
               [ngClass]="{ '-weekend-': airDay.weekend,
                            '-other-month-': airDay.other,
                            '-current-': airDay.current,
                            '-selected-':
                            airDate.getUTCFullYear() == airCalendar.year
                            && airDate.getUTCMonth() == airCalendar.month
                            && airDate.getUTCDate() == airDay.date
                            && !airDay.other,
                            '-disabled-': airDay.disabled }"
               (click)="setDate.emit(i)">{{airDay.date}}</div>
        </div>
      </div>

      <div *ngIf="airOptions.timepicker"
           timepicker
           [airOptions]="airOptions" [airCalendar]="airCalendar" (setDate)="setDate.emit(null)" class="datepicker--time -am-pm-"></div>
    </div>
  `
            }] }
];
DatepickerComponent.propDecorators = {
    airDate: [{ type: Input }],
    airOptions: [{ type: Input }],
    airCalendar: [{ type: Input }],
    airLanguage: [{ type: Input }],
    setDate: [{ type: Output }],
    setMonth: [{ type: Output }],
    monthSelection: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    DatepickerComponent.prototype.airDate;
    /** @type {?} */
    DatepickerComponent.prototype.airOptions;
    /** @type {?} */
    DatepickerComponent.prototype.airCalendar;
    /** @type {?} */
    DatepickerComponent.prototype.airLanguage;
    /** @type {?} */
    DatepickerComponent.prototype.setDate;
    /** @type {?} */
    DatepickerComponent.prototype.setMonth;
    /** @type {?} */
    DatepickerComponent.prototype.monthSelection;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyMi1haXItZGF0ZXBpY2tlci8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkUsT0FBTyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBMkNyRSxNQUFNLE9BQU8sbUJBQW1CO0lBeENoQztRQThDWSxZQUFPLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUNyQyxhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUN0QyxtQkFBYyxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7SUFDdEQsQ0FBQzs7O1lBakRBLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsY0FBYztnQkFDeEIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQ1Q7YUFDRjs7O3NCQUVFLEtBQUs7eUJBQ0wsS0FBSzswQkFDTCxLQUFLOzBCQUNMLEtBQUs7c0JBRUwsTUFBTTt1QkFDTixNQUFNOzZCQUNOLE1BQU07Ozs7SUFQUCxzQ0FBdUI7O0lBQ3ZCLHlDQUFnQzs7SUFDaEMsMENBQWtDOztJQUNsQywwQ0FBa0M7O0lBRWxDLHNDQUErQzs7SUFDL0MsdUNBQWdEOztJQUNoRCw2Q0FBb0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWlyQ2FsZW5kYXIsIEFpckxhbmd1YWdlLCBBaXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vY2xhc3Nlcyc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW2RhdGVwaWNrZXJdJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmF2IGNsYXNzPVwiZGF0ZXBpY2tlci0tbmF2XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci0tbmF2LWFjdGlvblwiIChjbGljayk9XCJzZXRNb250aC5lbWl0KGFpckNhbGVuZGFyLm1vbnRoIC0gMSlcIj48c3ZnPjxwYXRoIGQ9XCJNIDE3LDEyIGwgLTUsNSBsIDUsNVwiPjwvcGF0aD48L3N2Zz48L2Rpdj5cblxuICAgICAgPGRpdiAoY2xpY2spPVwibW9udGhTZWxlY3Rpb24uZW1pdCgpXCIgY2xhc3M9XCJkYXRlcGlja2VyLS1uYXYtdGl0bGVcIj57e2Fpckxhbmd1YWdlLm1vbnRoc1thaXJDYWxlbmRhci5tb250aF19fSwgPGk+e3thaXJDYWxlbmRhci55ZWFyfX08L2k+PC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS1uYXYtYWN0aW9uXCIgKGNsaWNrKT1cInNldE1vbnRoLmVtaXQoYWlyQ2FsZW5kYXIubW9udGggKyAxKVwiPjxzdmc+PHBhdGggZD1cIk0gMTQsMTIgbCA1LDUgbCAtNSw1XCI+PC9wYXRoPjwvc3ZnPjwvZGl2PlxuICAgIDwvbmF2PlxuXG4gICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLWNvbnRlbnRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS1kYXlzIGRhdGVwaWNrZXItLWJvZHkgYWN0aXZlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS1kYXlzLW5hbWVzXCI+XG4gICAgICAgICAgPGRpdiAqbmdGb3I9XCJsZXQgZGF5IG9mIFswLDEsMiwzLDQsNSw2XVwiIGNsYXNzPVwiZGF0ZXBpY2tlci0tZGF5LW5hbWVcIiBbY2xhc3MuLXdlZWtlbmQtXT1cImRheSA9PSA1IHx8IGRheSA9PSA2XCJcbiAgICAgICAgICA+e3thaXJMYW5ndWFnZVthaXJPcHRpb25zLmZ1bGxEYXlzID8gJ2RheXMnIDogJ2RheXNNaW4nXVtkYXldfX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLWNlbGxzIGRhdGVwaWNrZXItLWNlbGxzLWRheXNcIj5cbiAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cImxldCBhaXJEYXkgb2YgYWlyQ2FsZW5kYXIuYWlyRGF5czsgbGV0IGk9aW5kZXhcIlxuICAgICAgICAgICAgICAgY2xhc3M9XCJkYXRlcGlja2VyLS1jZWxsIGRhdGVwaWNrZXItLWNlbGwtZGF5XCJcbiAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJy13ZWVrZW5kLSc6IGFpckRheS53ZWVrZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctb3RoZXItbW9udGgtJzogYWlyRGF5Lm90aGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctY3VycmVudC0nOiBhaXJEYXkuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLXNlbGVjdGVkLSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWlyRGF0ZS5nZXRVVENGdWxsWWVhcigpID09IGFpckNhbGVuZGFyLnllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhaXJEYXRlLmdldFVUQ01vbnRoKCkgPT0gYWlyQ2FsZW5kYXIubW9udGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhaXJEYXRlLmdldFVUQ0RhdGUoKSA9PSBhaXJEYXkuZGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFhaXJEYXkub3RoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy1kaXNhYmxlZC0nOiBhaXJEYXkuZGlzYWJsZWQgfVwiXG4gICAgICAgICAgICAgICAoY2xpY2spPVwic2V0RGF0ZS5lbWl0KGkpXCI+e3thaXJEYXkuZGF0ZX19PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgKm5nSWY9XCJhaXJPcHRpb25zLnRpbWVwaWNrZXJcIlxuICAgICAgICAgICB0aW1lcGlja2VyXG4gICAgICAgICAgIFthaXJPcHRpb25zXT1cImFpck9wdGlvbnNcIiBbYWlyQ2FsZW5kYXJdPVwiYWlyQ2FsZW5kYXJcIiAoc2V0RGF0ZSk9XCJzZXREYXRlLmVtaXQobnVsbClcIiBjbGFzcz1cImRhdGVwaWNrZXItLXRpbWUgLWFtLXBtLVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICBgXG59KVxuZXhwb3J0IGNsYXNzIERhdGVwaWNrZXJDb21wb25lbnQge1xuICBASW5wdXQoKSBhaXJEYXRlOiBEYXRlO1xuICBASW5wdXQoKSBhaXJPcHRpb25zOiBBaXJPcHRpb25zO1xuICBASW5wdXQoKSBhaXJDYWxlbmRhcjogQWlyQ2FsZW5kYXI7XG4gIEBJbnB1dCgpIGFpckxhbmd1YWdlOiBBaXJMYW5ndWFnZTtcblxuICBAT3V0cHV0KCkgc2V0RGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICBAT3V0cHV0KCkgc2V0TW9udGggPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcbiAgQE91dHB1dCgpIG1vbnRoU2VsZWN0aW9uID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xufVxuIl19