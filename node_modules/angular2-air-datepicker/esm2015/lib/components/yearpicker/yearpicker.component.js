/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { AirCalendar } from '../../classes';
export class YearpickerComponent {
    constructor() {
        this.setYear = new EventEmitter();
        this.years = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const firstYear = this.airCalendar.year - 6;
        this.years = Array.from({ length: 12 }, (v, k) => firstYear + k);
    }
    /**
     * @return {?}
     */
    next() {
        for (let i = 0; i < this.years.length; i++) {
            this.years[i] += 10;
        }
    }
    /**
     * @return {?}
     */
    previous() {
        for (let i = 0; i < this.years.length; i++) {
            this.years[i] -= 10;
        }
    }
}
YearpickerComponent.decorators = [
    { type: Component, args: [{
                selector: '[yearpicker]',
                template: `
    <nav class="datepicker--nav">
      <div class="datepicker--nav-action" (click)="previous()"><svg><path d="M 17,12 l -5,5 l 5,5"></path></svg></div>

      <div class="datepicker--nav-title">{{years[1]}} - {{years[years.length - 2]}}</div>

      <div class="datepicker--nav-action" (click)="next()"><svg><path d="M 14,12 l 5,5 l -5,5"></path></svg></div>
    </nav>

    <div class="datepicker--content">
      <div class="datepicker--cells datepicker--cells-years">
        <div *ngFor="let year of years; let i=index" (click)="setYear.emit(year)" class="datepicker--cell datepicker--cell-year"
             [ngClass]="{ '-current-': year == airCalendar.currentYear, '-other-decade-': i == 0 || i == years.length - 1 }">{{year}}</div>
      </div>
    </div>
  `
            }] }
];
YearpickerComponent.propDecorators = {
    airCalendar: [{ type: Input }],
    setYear: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    YearpickerComponent.prototype.airCalendar;
    /** @type {?} */
    YearpickerComponent.prototype.setYear;
    /** @type {?} */
    YearpickerComponent.prototype.years;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhcnBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyMi1haXItZGF0ZXBpY2tlci8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3llYXJwaWNrZXIveWVhcnBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBVSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0UsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQXNCNUMsTUFBTSxPQUFPLG1CQUFtQjtJQW5CaEM7UUFzQlksWUFBTyxHQUFHLElBQUksWUFBWSxFQUFVLENBQUM7UUFFL0MsVUFBSyxHQUFhLEVBQUUsQ0FBQztJQWtCdkIsQ0FBQzs7OztJQWhCQyxRQUFROztjQUNBLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxDQUFDO1FBQzNDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNuRSxDQUFDOzs7O0lBRUQsSUFBSTtRQUNGLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMxQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNyQjtJQUNILENBQUM7Ozs7SUFFRCxRQUFRO1FBQ04sS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ3JCO0lBQ0gsQ0FBQzs7O1lBekNGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsY0FBYztnQkFDeEIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7R0FlVDthQUNGOzs7MEJBRUUsS0FBSztzQkFFTCxNQUFNOzs7O0lBRlAsMENBQWtDOztJQUVsQyxzQ0FBK0M7O0lBRS9DLG9DQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFpckNhbGVuZGFyIH0gZnJvbSAnLi4vLi4vY2xhc3Nlcyc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW3llYXJwaWNrZXJdJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmF2IGNsYXNzPVwiZGF0ZXBpY2tlci0tbmF2XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci0tbmF2LWFjdGlvblwiIChjbGljayk9XCJwcmV2aW91cygpXCI+PHN2Zz48cGF0aCBkPVwiTSAxNywxMiBsIC01LDUgbCA1LDVcIj48L3BhdGg+PC9zdmc+PC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLS1uYXYtdGl0bGVcIj57e3llYXJzWzFdfX0gLSB7e3llYXJzW3llYXJzLmxlbmd0aCAtIDJdfX08L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLW5hdi1hY3Rpb25cIiAoY2xpY2spPVwibmV4dCgpXCI+PHN2Zz48cGF0aCBkPVwiTSAxNCwxMiBsIDUsNSBsIC01LDVcIj48L3BhdGg+PC9zdmc+PC9kaXY+XG4gICAgPC9uYXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci0tY29udGVudFwiPlxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItLWNlbGxzIGRhdGVwaWNrZXItLWNlbGxzLXllYXJzXCI+XG4gICAgICAgIDxkaXYgKm5nRm9yPVwibGV0IHllYXIgb2YgeWVhcnM7IGxldCBpPWluZGV4XCIgKGNsaWNrKT1cInNldFllYXIuZW1pdCh5ZWFyKVwiIGNsYXNzPVwiZGF0ZXBpY2tlci0tY2VsbCBkYXRlcGlja2VyLS1jZWxsLXllYXJcIlxuICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJy1jdXJyZW50LSc6IHllYXIgPT0gYWlyQ2FsZW5kYXIuY3VycmVudFllYXIsICctb3RoZXItZGVjYWRlLSc6IGkgPT0gMCB8fCBpID09IHllYXJzLmxlbmd0aCAtIDEgfVwiPnt7eWVhcn19PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYFxufSlcbmV4cG9ydCBjbGFzcyBZZWFycGlja2VyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgQElucHV0KCkgYWlyQ2FsZW5kYXI6IEFpckNhbGVuZGFyO1xuXG4gIEBPdXRwdXQoKSBzZXRZZWFyID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgeWVhcnM6IG51bWJlcltdID0gW107XG5cbiAgbmdPbkluaXQgKCkge1xuICAgIGNvbnN0IGZpcnN0WWVhciA9IHRoaXMuYWlyQ2FsZW5kYXIueWVhciAtIDY7XG4gICAgdGhpcy55ZWFycyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEyIH0sICh2LCBrKSA9PiBmaXJzdFllYXIgKyBrKTtcbiAgfVxuXG4gIG5leHQgKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy55ZWFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy55ZWFyc1tpXSArPSAxMDtcbiAgICB9XG4gIH1cblxuICBwcmV2aW91cyAoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnllYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnllYXJzW2ldIC09IDEwO1xuICAgIH1cbiAgfVxufVxuIl19